---
title: "taxa_worms"
editor_options: 
  chunk_output_type: console
---

## Overview

Goal: Get the full taxonomic hierarchy for all observed taxa in the larval
and egg counts from the NOAA CalCOFI database from the World Register of Marine 
Species (WoRMS; [marinespecies.org](https://www.marinespecies.org)).

```{r setup}
librarian::shelf(
  DBI, dplyr, DT, duckdb, fs, glue, here, htmltools, purrr, readr, stringr, 
  tidyr,
  quiet = T)
options(readr.show_col_types = F)

url_cc         <- "https://file.calcofi.io/calcofi.duckdb"
tmp_db         <- here("data/tmp.duckdb")
cc_db          <- glue("/share/data/swfsc.noaa.gov/calcofi.duckdb")
spp_db         <- glue("~/My Drive/projects/msens/data/derived/spp.duckdb")
species_csv    <- here("data/species.csv")
taxonomy_csv   <- here("data/taxonomy.csv")
taxon_rank_csv <- here("data/taxon_rank.csv")

is_server     <-  Sys.info()[["sysname"]] == "Linux"
is_ben_laptop <- Sys.info()[["nodename"]] == "Bens-MacBook-Air.local"

con_tmp <- dbConnect(duckdb(), dbdir = tmp_db)
res <- dbExecute(con_tmp, glue("ATTACH IF NOT EXISTS '{url_cc}' AS calcofi; USE calcofi"))

# helper functions ----

id2url <- function(id, type = "worms") {
  # add urls for WoRMS and ITIS, show datatable with links
  if (type == "worms") {
    glue("<a href='https://www.marinespecies.org/aphia.php?p=taxdetails&id={id}' _target='_blank'>{id}</a>")
  } else if (type == "itis") {
    glue("<a href='https://itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value={id}' _target='_blank'>{id}</a>")
  } else {
    stop("Unknown type. Use 'worms' or 'itis'.")
  }
}

showtable <- function(data, filename = "table", escape = F, rownames = F, pageLength = NULL) {
  # datatable with escape = F for links and download buttons with filenames
  
  n_max <- nrow(data)
  # set lengthMenu to vector of c(5, 50, 100, n_max), excluding any options less than n_max
  
  lengthMenu <- c(5, 50, 100, n_max)
  if (n_max < lengthMenu[1]) {
    lengthMenu <- c(n_max)
  } else if (n_max < lengthMenu[2]) {
    lengthMenu <- c(lengthMenu[1], n_max)
  } else if (n_max < lengthMenu[3]) {
    lengthMenu <- c(lengthMenu[1:2], n_max)
  }
  
  if (!is.null(pageLength)){
    pageLength <- as.integer(pageLength)
    lengthMenu <- c(lengthMenu, pageLength) |> unique() |> sort()
  } else{
    pageLength <- lengthMenu[1]
  }
  
  datatable(
    data,
    escape     = escape,
    rownames   = rownames,
    extensions = "Buttons", 
    filter     = "top",
    options    = list(
      dom        = "Blfrtip",
      pageLength = pageLength,
      lengthMenu = lengthMenu,
      buttons    = list( 
        list(extend = "csv",   filename = filename),
        list(extend = "excel", filename = filename) )))
}
```

## Update CalCOFI species table

### Fetch CalCOFI species

```{r tbl-species_init}
#| tbl-cap: "CalCOFI species with original WoRMS and ITIS IDs"

# dbListTables(con_tmp)
# [1] "cruise"   "egg"      "grid"     "larva"    "net"      "ship"    
# [7] "site"     "site_seg" "species"  "tow"      "tow_type"

d <- tbl(con_tmp, "calcofi.species") |> 
  select(
    sp_id,
    scientific_name,
    common_name,
    itis_id_old  = itis_tsn,
    worms_id_old = aphia_id) |> 
  collect()

# https://www.marinespecies.org/aphia.php?p=taxdetails&id=293496
# https://itis.gov/servlet/SingleRpt/SingleRpt?search_topic=TSN&search_value=168736

d |> 
  mutate(
    worms_old_url = id2url(worms_id_old, "worms"),
    itis_old_url  = id2url(itis_id_old,  "itis")) |> 
  select(sp_id, common_name, scientific_name, worms_id_old = worms_old_url, itis_id_old = itis_old_url) |> 
  showtable( 
    "calcofi_species_init")
```

### Use pre-processed WoRMS database

The entire WoRMS database has already been downloaded from [World Register of Marine Species at ChecklistBank.org](https://www.checklistbank.org/dataset/2011/download), which seems much more extensive (2.7 GB) than the one downloadable directly 
from [marinespecies.org/download](https://www.marinespecies.org/download/) (547.8 MB).

This ChecklistBank.org WoRMS database was ingested into a duckdb database in
the standard DarwinCore format as with other major taxonomic authorities
(GBIF, ITIS, IUCN) with the notebook [ingest_taxon.qmd](https://github.com/MarineSensitivity/workflows/blob/9fdfdb6ee98148755c50c39e06d3b9b3469363be/ingest_taxon.qmd). This is only locally available on Ben's laptop for the moment, but can be recreated by running the `ingest_taxon.qmd` workflow.

```{r con_spp}
#| eval: !expr is_ben_laptop

con_spp <- dbConnect(duckdb(dbdir = spp_db, read_only = F))

# dbListTables(con_spp)
# [1] "gbif"             "gbif_vernacular"  "iucn_redlist"
# [4] "iucn_vernacular"  "worms"            "worms_vernacular"

# dbListFields(con_spp, "worms")
#  [1] "taxonID"                  "scientificNameID"
#  [3] "acceptedNameUsageID"      "parentNameUsageID"
#  [5] "namePublishedInID"        "scientificName"
#  [7] "acceptedNameUsage"        "parentNameUsage"
#  [9] "namePublishedIn"          "namePublishedInYear"
# [11] "kingdom"                  "phylum"
# [13] "class"                    "order"
# [15] "family"                   "genus"
# [17] "subgenus"                 "specificEpithet"
# [19] "infraspecificEpithet"     "taxonRank"
# [21] "scientificNameAuthorship" "nomenclaturalCode"
# [23] "taxonomicStatus"          "nomenclaturalStatus"
# [25] "modified"                 "bibliographicCitation"
# [27] "references"               "license"
# [29] "rightsHolder"             "datasetName"
# [31] "institutionCode"          "datasetID"

# dbListFields(con_spp, "worms_vernacular")
# "taxonID"  "vernacularName"  "source"  "language"  "isPreferredName"
```

### Update WoRMS ID

```{r tbl-worms_id}
#| tbl-cap: "CalCOFI species changes to WoRMS IDs."
#| eval: !expr is_ben_laptop

d <- d |> # 1,148 × 5
  left_join(
    tbl(con_spp, "worms") |>
      filter(taxonID %in% d$worms_id_old) |> 
      select(
        taxonID,
        worms_id              = acceptedNameUsageID,
        worms_scientific_name = acceptedNameUsage) |>
      collect(),
    by = join_by(worms_id_old == taxonID))

d_worms_chgs <- d |> 
  filter(
    (worms_id_old != worms_id) | 
      (scientific_name != worms_scientific_name)) |> 
  select(
    sp_id, common_name, 
    scientific_name, worms_scientific_name, 
    worms_id_old, worms_id)

if (nrow(d_worms_chgs) == 0){
  message("No changes to WoRMS IDs or scientific_name found.")
} else {
  # message("Found ", nrow(d_worms_chgs), " changes to WoRMS IDs.")
  d_worms_chgs |> 
    mutate(
      worms_old_url = id2url(worms_id_old, "worms"),
      worms_url     = id2url(worms_id,     "worms")) |> 
  select(
    sp_id, common_name, 
    scientific_name, worms_scientific_name,
    worms_id_old = worms_old_url, worms_id = worms_url) |> 
    showtable(
      "calcofi_species_worms_chgs")
}
```

### Update ITIS ID

```{r tbl-itis_id}
#| tbl-cap: "CalCOFI species changes to ITIS IDs."
#| eval: !expr is_ben_laptop

d <- d |> # 1,148 × 5
  left_join(
    tbl(con_spp, "itis") |>
      filter(taxonID %in% d$itis_id_old) |> 
      select(
        taxonID,
        itis_id_new = acceptedNameUsageID) |>
      collect(),
    by = join_by(itis_id_old == taxonID)) |> 
  mutate(
    itis_id = coalesce(itis_id_new, itis_id_old)) |> 
  select(-itis_id_new)

d <- d |>
  left_join(
    tbl(con_spp, "itis") |>
      filter(taxonID %in% d$itis_id) |> 
      select(
        taxonID,
        itis_scientific_name = scientificName) |>
      collect(),
    by = join_by(itis_id == taxonID))

d_itis_chgs <- d |> 
  filter(
    (itis_id_old != itis_id) |
      (scientific_name != itis_scientific_name)) |> 
  select(
    sp_id, common_name,
    scientific_name, itis_scientific_name,
    itis_id_old, itis_id)

if (nrow(d_itis_chgs) == 0){
  message("No changes to ITIS IDs found.")
} else {
  message("Found ", nrow(d_itis_chgs), " changes to ITIS IDs.")
  d_itis_chgs |> 
    mutate(
      itis_old_url = id2url(itis_id_old, "itis"),
      itis_url     = id2url(itis_id,     "itis")) |> 
    select(
      sp_id, common_name, 
      scientific_name, itis_scientific_name,
      itis_id_old = itis_old_url, itis_id = itis_url) |> 
    showtable(
      "calcofi_species_itis_chgs")
}
```

### Get WoRMS invalid scientific names (for searching)

TODO: Fold this later into output tables.

```{r tbl-worms_invalid}
#| tbl-cap: "CalCOFI species with alternative invalid WoRMS scientific names."
#| eval: !expr is_ben_laptop

# TODO: get common names across taxons in a separate table and look up match across any for preferred

d_worms_invalid <- d |> # 1,148 × 8
  select(-itis_id_old, -worms_id_old, -itis_id, -itis_scientific_name) |> 
  left_join(
    tbl(con_spp, "worms") |>
      filter(
        acceptedNameUsageID %in% d$worms_id,
        taxonID              !=  acceptedNameUsageID) |> 
      select(
        worms_id                      = acceptedNameUsageID,
        worms_invalid_id              = taxonID,
        worms_invalid_scientific_name = scientificName,
        worms_invalid_status          = taxonomicStatus) |>
      collect(),
    by           = join_by(worms_id),
    relationship = "many-to-many") |> 
  filter(!is.na(worms_invalid_id)) |> 
  arrange(sp_id, worms_invalid_scientific_name)
# View(d_invalid)
# d_invalid |>
#   glimpse()

if (nrow(d_worms_invalid) == 0){
  message("No alternative invalid WoRMS scientific names found.")
} else {
  # message("Found ", nrow(d_worms_invalid), " alternative invalid WoRMS scientific names")
  d_worms_invalid |> 
    mutate(
      worms_url         = id2url(worms_id, "worms"),
      worms_invalid_url = id2url(worms_invalid_id, "worms")) |> 
  select(
    sp_id, scientific_name, 
    common_name, worms_scientific_name, 
    worms_id = worms_url,
    worms_invalid_scientific_name,
    worms_invalid_id = worms_invalid_url,
    worms_invalid_status) |> 
    showtable(
      "calcofi_species_worms_invalid_alternatives")
}
```

### Get WoRMS common name

```{r tbl-worms_common_name}
#| tbl-cap: "CalCOFI species differences with WoRMS common names."
#| eval: !expr is_ben_laptop

# TODO: get common names across taxons in a separate table and look up match across any for preferred

d <- d |> # 1,148 × 8
  left_join(
    tbl(con_spp, "worms_vernacular") |>
      mutate(
        has_source = !is.na(source)) |> 
      filter(
        taxonID %in% d$worms_id,
        language == "ENG") |> 
      select(
        taxonID,
        worms_common_name  = vernacularName,
        isPreferredName,
        has_source) |>
      collect(),
    by           = join_by(worms_id == taxonID),
    relationship = "many-to-many") |> 
  slice_max(
    by        = scientific_name,
    order_by  = tibble(isPreferredName, has_source),
    with_ties = F) |> 
  select(-isPreferredName, -has_source)

d_worms_cn_chgs <- d |> 
  filter(
    !is.na(worms_common_name),
    (tolower(common_name) != tolower(worms_common_name)) ) |> 
  select(
    sp_id, scientific_name, 
    common_name, worms_common_name, 
    worms_id)

if (nrow(d_worms_cn_chgs) == 0){
  message("No differences with WoRMS common name found.")
} else {
  message("Found ", nrow(d_worms_cn_chgs), " differences with WoRMS common name")
  d_worms_cn_chgs |> 
    mutate(
      worms_id = id2url(worms_id, "worms")) |> 
    showtable(
      "calcofi_species_worms_common_chgs")
}
```

### Get ITIS common name

```{r tbl-itis_common_name}
#| tbl-cap: "CalCOFI species differences with ITIS common names."
#| eval: !expr is_ben_laptop

d <- d |> # 1,148 × 10
  left_join(
    tbl(con_spp, "itis_vernacular") |>
      filter(
        taxonID %in% d$itis_id,
        language == "English") |> 
      group_by(taxonID) |> 
      summarize(
        # get one common name per taxonID
        itis_common_name = first(vernacularName), 
        .groups = "drop") |>
      collect(),
    by = join_by(itis_id == taxonID))

d_itis_cn_chgs <- d |> 
  filter(
    !is.na(itis_common_name),
      (tolower(common_name) != tolower(itis_common_name)) ) |> 
  select(
    sp_id, scientific_name, 
    common_name, itis_common_name, 
    itis_id)

if (nrow(d_itis_cn_chgs) == 0){
  message("No differences with itis common name found.")
} else {
  message("Found ", nrow(d_itis_cn_chgs), " differences with itis common name")
  d_itis_cn_chgs |> 
    mutate(
      itis_id = id2url(itis_id, "itis")) |> 
    showtable(
      "calcofi_species_itis_common_chgs")
}
```

### Update final species table

```{r tbl-species_csv}
#| tbl-cap: "CalCOFI updated species table."
#| eval: !expr is_ben_laptop

d <- d |> 
  rename(
    scientific_name_old = scientific_name,
    common_name_old     = common_name) |> 
  mutate(
    scientific_name = coalesce(worms_scientific_name, itis_scientific_name, scientific_name_old),
    common_name     = coalesce(common_name_old, worms_common_name, itis_common_name)) |> 
  select(
    sp_id, scientific_name, common_name, 
    worms_id, itis_id,
    scientific_name_worms = worms_scientific_name, common_name_worms = worms_common_name,
    scientific_name_itis  = itis_scientific_name,  common_name_itis  = itis_common_name,
    scientific_name_old, common_name_old, worms_id_old, itis_id_old)

write_csv(d, species_csv)

d |> 
  mutate(
    worms_id     = id2url(worms_id,     "worms"),
    worms_id_old = id2url(worms_id_old, "worms"),
    itis_id      = id2url(itis_id,      "itis"),
    itis_id_old  = id2url(itis_id_old,  "itis")) |> 
  showtable("calcofi_species_updated")
```

## Get full taxonomic hierarchy

### Get parent taxa, 1 example

- [USING KEY in Recursive CTEs – DuckDB](https://duckdb.org/2025/05/23/using-key.html)

```{r tbl-taxon_parentage_1}
#| tbl-cap: "CalCOFI taxonomic parentage example for anchovies _Clupeiformes_ (sp_id: 9)."
#| eval: !expr is_ben_laptop

d_species <- read_csv(species_csv)

# f_i <- dbListFields(con_spp, "itis")
# f_w <- dbListFields(con_spp, "worms")
# setdiff(f_i, f_w) # "completeness"
# setdiff(f_w, f_i) # "completeness"
#  [1] "scientificNameID"      "namePublishedInID"     "acceptedNameUsage"    
#  [4] "parentNameUsage"       "kingdom"               "phylum"               
#  [7] "class"                 "order"                 "family"               
# [10] "genus"                 "subgenus"              "specificEpithet"      
# [13] "infraspecificEpithet"  "nomenclaturalCode"     "modified"             
# [16] "bibliographicCitation" "references"            "license"              
# [19] "rightsHolder"          "datasetName"           "institutionCode"      
# [22] "datasetID"             "isMarine"              "isFreshwater"         
# [25] "isTerrestrial"         "isExtinct"             "isBrackish"  
# f_i |> setdiff("completeness")
#  [1] "taxonID"                  "parentNameUsageID"        "acceptedNameUsageID"     
#  [4] "scientificName"           "scientificNameAuthorship" "taxonRank"               
#  [7] "taxonomicStatus"          "nomenclaturalStatus"      "namePublishedIn"         
# [10] "namePublishedInYear"

# Function to get taxon and all parent taxa using recursive CTE
get_taxon_parentage <- function(taxonID, authority = "worms"){
  
  query_sql <- glue("
    WITH RECURSIVE taxon_hierarchy AS (
      -- Base case: find the initial taxon (and resolve to accepted if it's a synonym)
      SELECT 
        taxonID,
        acceptedNameUsageID,
        parentNameUsageID,
        scientificName,
        scientificNameAuthorship,
        taxonRank,
        taxonomicStatus,
        nomenclaturalStatus,
        namePublishedInYear,
        0 as level
      FROM {authority} 
      WHERE taxonID = ?
      
      UNION ALL
      
      -- Recursive case: find parent taxa (using the accepted parent)
      SELECT 
        t.taxonID,
        t.acceptedNameUsageID,
        t.parentNameUsageID,
        t.scientificName,
        t.scientificNameAuthorship,
        t.taxonRank,
        t.taxonomicStatus,
        t.nomenclaturalStatus,
        t.namePublishedInYear,
        th.level + 1 as level
      FROM {authority} t
      INNER JOIN taxon_hierarchy th ON t.taxonID = th.parentNameUsageID
      -- Ensure we're getting the accepted version of the parent
      WHERE t.taxonID = t.acceptedNameUsageID  -- Only accepted taxa (not synonyms)
        AND th.level < 50  -- Safety limit
    )
    SELECT * FROM taxon_hierarchy
    ORDER BY level, taxonRank")
  
  dbGetQuery(con_spp, query_sql, params = list(taxonID)) |> 
    mutate(
      authority           = !!authority,
      namePublishedInYear = as.character(namePublishedInYear)) |> 
    relocate(authority) |> 
    tibble()
}

d_tp_ex <- d_species |> 
  filter(common_name == "anchovies") |>  # sp_id: 9; scientific_name: Clupeiformes
  pull(worms_id) |>
  get_taxon_parentage("worms")

d_tp_ex |> 
  select(level, taxonID, parentNameUsageID, scientificName, taxonRank) |>
  showtable("calcofi_taxon_parentage_example", pageLength = 10)
```

### Get parent taxa for all taxon

```{r tbl-taxon_parentage_all}
#| tbl-cap: "CalCOFI taxonomic parentage example for anchovies _Clupeiformes_ (sp_id: 9)."
#| eval: !expr is_ben_laptop

d_taxonomy <- d_species |>
  select(worms_id) |>
  filter(!is.na(worms_id)) |> 
  mutate(
    data = map(worms_id, get_taxon_parentage, "worms")) |> 
  bind_rows(
    d_species |>
      select(itis_id) |> 
      filter(!is.na(itis_id)) |> 
      mutate(
        data = map(itis_id, get_taxon_parentage, "itis") )) |> #  2,296
  unnest(data) |>                                              # 15,702
  select(-level, -worms_id, -itis_id) |> 
  select(
    authority, taxonID, acceptedNameUsageID, scientificName, taxonRank, 
    parentNameUsageID, taxonomicStatus, nomenclaturalStatus, 
    scientificNameAuthorship, namePublishedInYear) |> 
  distinct()                                                   #  2,794

stopifnot(duplicated(select(d_taxonomy, authority, taxonID)) |> sum() == 0)

write_csv(d_taxonomy, taxonomy_csv)

d_taxonomy |> 
  showtable("calcofi_taxonomy")
```

### Get taxonomic ranks

```{r tbl-taxon_rank}
#| tbl-cap: "Taxonomic ranks in WoRMS and ITIS."
#| eval: !expr is_ben_laptop

tr_w <- tbl(con_spp, "worms") |>
  distinct(taxonRank) |>
  pull(taxonRank)
tr_i <- tbl(con_spp, "itis") |>
  distinct(taxonRank) |>
  pull(taxonRank)

taxa_ranks_chr <- c(
  "Kingdom", "Subkingdom", "Infrakingdom",
  "Superdivision", "Superphylum", "Division", "Phylum", "Phylum (Division)", 
  "Subdivision", "Subphylum", "Subphylum (Subdivision)", "Infradivision", 
  "Infraphylum", "Parvphylum",
  "Gigaclass", "Megaclass", "Superclass", "Class", "Subterclass", 
  "Subclass", "Infraclass",
  "Superorder", "Order", "Suborder", "Infraorder", "Parvorder",
  "Section", "Subsection",
  "Superfamily", "Epifamily", "Family", "Subfamily",
  "Supertribe", "Tribe", "Subtribe",
  "Genus", "Subgenus",
  "Series", "Subseries",
  "Species", "Subspecies",
  "Natio", "Mutatio",
  "Form", "Forma", "Subform", "Subforma",
  "Variety", "Subvariety",
  "Coll. sp.", "Aggr.")
stopifnot(length(setdiff(na.omit(tr_w), taxa_ranks_chr)) == 0)

d_taxa_rank <- tibble(
  taxonRank  = taxa_ranks_chr,
  rank_order = 1:length(taxa_ranks_chr))

write_csv(d_taxa_rank, taxon_rank_csv)

showtable(d_taxa_rank, "calcofi_taxa_ranks")
```

## Write tables to calcofi db

The following tables are written to the `calcofi` database on the server:

- `species`
- `taxonomy`
- `taxon_rank`

```{r eval_f}
knitr::opts_chunk$set(eval = F)
```

```{r write_taxon_taxonomy_calcofidb}
#| eval: !expr is_server

con_cc <- dbConnect(duckdb(), dbdir = cc_db, read_only = F)

d_species    <- read_csv(species_csv)
d_taxonomy   <- read_csv(taxonomy_csv)
d_taxon_rank <- read_csv(taxon_rank_csv)

d_species <- d_species |> 
  select(
    sp_id, scientific_name, common_name, 
    worms_id, itis_id) |> 
    # Excluding fields:
    # scientific_name_worms, common_name_worms,
    # scientific_name_itis,  common_name_itis,
    # scientific_name_old,   common_name_old,
    # worms_id_old,          itis_id_old
  mutate(
    sp_id    = as.integer(sp_id),
    worms_id = as.integer(worms_id),
    itis_id  = as.integer(itis_id))

d_taxonomy <- d_taxonomy |> 
  select(
    authority, taxonID, acceptedNameUsageID, scientificName, taxonRank, 
    parentNameUsageID, taxonomicStatus, nomenclaturalStatus, 
    scientificNameAuthorship, namePublishedInYear) |>
  mutate(
    taxonID                  = as.integer(taxonID),
    acceptedNameUsageID      = as.integer(acceptedNameUsageID),
    parentNameUsageID        = as.integer(parentNameUsageID))
  
d_taxon_rank <- d_taxon_rank |> 
  select(taxonRank, rank_order) |>
  mutate(
    rank_order = as.integer(rank_order))

dbWriteTable(con_cc, "species",   d_species,    overwrite = T)
dbWriteTable(con_cc, "taxonomy",  d_taxonomy,   overwrite = T)
dbWriteTable(con_cc, "taxa_rank", d_taxon_rank, overwrite = T)
```

## Get taxonomic children

```{r tbl-taxon_children_1}
#| tbl-cap: "CalCOFI taxonomic children example for rockfishes _Sebastes_ (sp_id: 683)."

# Function to get all children (descendants) of a given taxon
get_taxon_children <- function(taxonID, authority = "worms") {
  
  query_sql <- glue("
    WITH RECURSIVE taxon_children AS (
      -- Base case: find the parent taxon
      SELECT 
        taxonID,
        scientificNameID,
        acceptedNameUsageID,
        parentNameUsageID,
        scientificName,
        parentNameUsage,
        taxonRank,
        taxonomicStatus,
        0 as depth_level
      FROM taxonomy 
      WHERE taxonID = ?
      
      UNION ALL
      
      -- Recursive case: find children taxa
      SELECT 
        t.taxonID,
        t.scientificNameID,
        t.acceptedNameUsageID,
        t.parentNameUsageID,
        t.scientificName,
        t.parentNameUsage,
        t.taxonRank,
        t.taxonomicStatus,
        tc.depth_level + 1 as depth_level
      FROM taxonomy t
      INNER JOIN taxon_children tc ON t.parentNameUsageID = tc.taxonID
      WHERE 
        t.parentNameUsageID IS NOT NULL AND
        t.authority = '{authority}'
    )
    SELECT tc.*, COALESCE(tr.rank_order, 99) as rank_order
    FROM taxon_children tc
    LEFT JOIN taxa_rank tr ON tc.taxonRank = tr.taxonRank
    ORDER BY tc.depth_level, COALESCE(tr.rank_order, 99), tc.scientificName")
  
  dbGetQuery(con_cc, query_sql, params = list(scientific_name)) |> 
    tibble()
}

# TODO: arguments or extra function to get:
# - [ ] get_direct_children
# - [ ] get_taxon_children_depth: children up to a specific depth level
# - [ ] get_children_by_rank: get children of a specific taxonomic rank

# Example usage:

# First, create the taxa_ranks lookup table (run once)
# create_taxa_ranks_table(con_spp)

# Get all descendants of a family
# family_children <- get_taxon_children(con_spp, "Sebastidae")

# Get only direct children (genera within the family)
# direct_children <- get_direct_children(con_spp, "Sebastidae")

# Get children up to 2 levels deep
# shallow_children <- get_taxon_children_depth(con_spp, "Sebastidae", max_depth = 2)

# Get all species within a genus
# species_in_genus <- get_children_by_rank(con_spp, "Sebastes", "Species")
```

## Close db connection(s)

```{r cleanup_dbs}
dbDisconnect(con_cc, shutdown = T); duckdb_shutdown(duckdb()); rm(con_cc)

if (is_ben_laptop)
  dbDisconnect(con_spp, shutdown = T); duckdb_shutdown(duckdb()); rm(con_spp)
```

Note that you might need to sometimes restart your R session (under Session menu in RStudio) to connect to the local duckdb.

